#!/usr/bin/env python3
#
# socketmap-sqlite
# by Keith Gaughan (https://github.com/kgaughan/)
#
# This implements the sendmail socketmap protocol to allow an SQLite database
# to be queried out of process.
#
# Copyright (c) Keith Gaughan, 2017. See 'LICENSE' for license details.
#

from __future__ import print_function

import argparse
import contextlib
try:
    import configparser
except ImportError:
    import ConfigParser as configparser
import os
import os.path
import re
import select
import sqlite3
import sys


FUNC_REF_PATTERN = re.compile(r"""
    ^
    (?P<module>
        [a-z_][a-z0-9_]*(?:\.[a-z_][a-z0-9_]*)*
    )
    :
    (?P<object>
        [a-z_][a-z0-9_]*(?:\.[a-z_][a-z0-9_]*)*
    )
    $
    """, re.I | re.X)


def match(name):
    matches = FUNC_REF_PATTERN.match(name)
    if not matches:
        raise ValueError("Malformed callable '{}'".format(name))
    return matches.group('module'), matches.group('object')


def resolve(module_name, obj_name):
    """
    Resolve a named object in a module.
    """
    segments = obj_name.split('.')
    obj = __import__(module_name, fromlist=segments[:1])
    for segment in segments:
        obj = getattr(obj, segment)
    return obj


class MalformedNetstringError(Exception):
    pass


def read_netstring(fp):
    """
    Reads a single netstring.
    """
    n = ""
    while True:
        c = fp.read(1)
        if c == '':
            return None
        if c == ':':
            break
        if len(n) > 10:
            raise MalformedNetstringError
        if c == '0' and n == '':
            # We can't allow leading zeros.
            if fp.read(1) != ':':
                raise MalformedNetstringError
            n = c
            break
        n += c
    n = int(n, 10)
    result = ""
    while n > 0:
        segment = fp.read(n)
        n -= len(segment)
        result += segment
    if fp.read(1) != ',':
        raise MalformedNetstringError
    return result


def write_netstring(fp, response):
    fp.write('{}:{},'.format(len(response), response))
    fp.flush()


def parse_config(fp):
    def passthrough(arg):
        return [arg]

    def local_part(arg):
        return [arg.split('@', 1)[0]]

    def domain_part(arg):
        return [arg.split('@', 1)[1]]

    cp = configparser.RawConfigParser()
    cp.readfp(fp)

    result = {
        'db_path': cp.get('database', 'path'),
        'tables': {},
    }

    for section in cp.sections():
        if section.startswith('table:'):
            _, table_name = section.split(':', 1)
            if not cp.has_option(section, 'query'):
                continue

            try:
                transform_name = cp.get(section, 'transform')
            except configparser.NoOptionError:
                transform_name = 'all'
            if transform_name == 'all':
                transform = passthrough
            elif transform_name == 'local':
                transform = local_part
            elif transform_name == 'domain':
                transform = domain_part
            else:
                transform = resolve(*match(transform_name))

            result['tables'][table_name] = {
                'transform': transform,
                'query': cp.get(section, 'query'),
            }

    return result


def server(conn, timeout, tables):
    try:
        while True:
            # Wait a short period before exiting.
            iready, _, _ = select.select([sys.stdin], (), (), timeout)
            if len(iready) == 0:
                break

            request = read_netstring(sys.stdin)

            table_name, arg = request.split(' ', 1)

            table = tables.get(table_name)
            if table is None:
                write_netstring(sys.stdout,
                                'PERM no such table: ' + table_name)
                continue

            cur = conn.cursor()
            try:
                cur.execute(table['query'], table['transform'](arg))
                result = cur.fetchone()
            finally:
                cur.close()

            if result is None:
                write_netstring(sys.stdout, 'NOTFOUND ')
            else:
                write_netstring(sys.stdout, 'OK ' + str(result[0]))
    except MalformedNetstringError:
        write_netstring(sys.stdout, 'PERM malformed netstring')
    except Exception as exc:
        write_netstring(sys.stdout, 'PERM ' + str(exc))


def main():
    parser = argparse.ArgumentParser(description='SQLite socketmap daemon.')
    parser.add_argument('--config',
                        help='Path to config file',
                        type=argparse.FileType(),
                        default='/etc/socketmap-sqlite.ini')
    parser.add_argument('--timeout',
                        help='Number of seconds to wait before exiting',
                        type=int,
                        default=2)
    args = parser.parse_args()

    with contextlib.closing(args.config):
        cfg = parse_config(args.config)

    if not os.path.exists(cfg['db_path']):
        print("error: cannot find {}".format(cfg['db_path']), file=sys.stderr)
        return 2

    with contextlib.closing(sqlite3.connect(cfg['db_path'])) as conn:
        server(conn, args.timeout, cfg['tables'])

    return 0


if __name__ == '__main__':
    sys.exit(main())

# vim:set ft=python et:

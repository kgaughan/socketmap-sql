#!/usr/bin/env python3
#
# socketmap-sqlite
# by Keith Gaughan (https://github.com/kgaughan/)
#
# This implements the sendmail socketmap protocol to allow an SQLite database
# to be queried out of process.
#
# Copyright (c) Keith Gaughan, 2017. See 'LICENSE' for license details.
#

from __future__ import print_function

import argparse
import contextlib
try:
    import configparser
except ImportError:
    import ConfigParser as configparser
import os
import os.path
import re
import sqlite3
import sys


FUNC_REF_PATTERN = re.compile(r"""
    ^
    (?P<module>
        [a-z_][a-z0-9_]*(?:\.[a-z_][a-z0-9_]*)*
    )
    :
    (?P<object>
        [a-z_][a-z0-9_]*(?:\.[a-z_][a-z0-9_]*)*
    )
    $
    """, re.I | re.X)


def match(name):
    matches = FUNC_REF_PATTERN.match(name)
    if not matches:
        raise ValueError("Malformed callable '{}'".format(name))
    return matches.group('module'), matches.group('object')


def resolve(module_name, obj_name):
    """
    Resolve a named object in a module.
    """
    segments = obj_name.split('.')
    obj = __import__(module_name, fromlist=segments[:1])
    for segment in segments:
        obj = getattr(obj, segment)
    return obj


class MalformedNetstringError(Exception):
    pass


def netstring_reader(fp):
    while True:
        n = ""
        while True:
            c = fp.read(1)
            if c == '':
                return
            if c == ':':
                break
            if len(n) > 10:
                raise MalformedNetstringError
            if c == '0' and n == '':
                # We can't allow leading zeros.
                if fp.read(1) != ':':
                    raise MalformedNetstringError
                n = c
                break
            n += c
        n = int(n, 10)
        payload = fp.read(n)
        if len(payload) < n:
            return
        if fp.read(1) != ',':
            raise MalformedNetstringError
        yield payload


def write_netstring(response):
    sys.stdout.write('{}:{},'.format(len(response), response))
    sys.stdout.flush()


def parse_config(fp):
    def passthrough(arg):
        return arg

    def local_part(arg):
        return arg.split('@', 1)[0]

    def domain_part(arg):
        return arg.split('@', 1)[1]

    cp = configparser.RawConfigParser()
    cp.readfp(fp)

    result = {
        'db_path': cp.get('database', 'path'),
        'tables': {},
    }

    for section in cp.sections():
        if section.startswith('table:'):
            _, table_name = section.split(':', 1)
            if not cp.has_option(section, 'query'):
                continue

            try:
                transform_name = cp.get(section, 'transform')
            except configparser.NoOptionError:
                transform_name = 'all'
            if transform_name == 'all':
                transform = passthrough
            elif transform_name == 'local':
                transform = local_part
            elif transform_name == 'domain':
                transform = domain_part
            else:
                transform = resolve(*match(transform_name))

            result['tables'][table_name] = {
                'transform': transform,
                'query': cp.get(section, 'query'),
            }

    return result


def main():
    parser = argparse.ArgumentParser(description='SQLite socketmap daemon.')
    parser.add_argument('--config',
                        help='Path to config file',
                        type=argparse.FileType(),
                        default='/etc/socketmap-sqlite.ini')
    args = parser.parse_args()

    with contextlib.closing(args.config):
        cfg = parse_config(args.config)

    if not os.path.exists(cfg['db_path']):
        print("error: cannot find {}".format(cfg['db_path']), file=sys.stderr)
        return 2

    with contextlib.closing(sqlite3.connect(cfg['db_path'])) as conn:
        try:
            for request in netstring_reader(sys.stdin):
                table_name, arg = request.split(' ', 1)

                table = cfg['tables'].get(table_name)
                if table is None:
                    write_netstring('PERM no such table: ' + table_name)
                    continue

                cur = conn.cursor()
                try:
                    cur.execute(table['query'], [table['transform'](arg)])
                    result = cur.fetchone()
                finally:
                    cur.close()

                if result is None:
                    write_netstring('NOTFOUND ')
                else:
                    write_netstring('OK ' + str(result[0]))
        except MalformedNetstringError:
            write_netstring('PERM malformed netstring')
        except Exception as exc:
            write_netstring('PERM ' + str(exc))

    return 0


if __name__ == '__main__':
    sys.exit(main())

# vim:set ft=python et:
